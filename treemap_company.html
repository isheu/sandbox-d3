<html>
   <head>
      <script type="text/javascript" src="d3.v2.js"></script>
      <script type="text/javascript" src="treemap_data.js"></script>
      <script type="text/javascript" src="treemap_cluster_company.js"></script>
      <!--<script type="text/javascript" src="treemap_gen_tooltip.js"></script> -->
      <!--<script type="text/javascript" src="treemap_search_thru.js"></script> -->
      <!-- 
      To do: tooltip
      Adapt for d3.csv
      Extend, dive deeper into nesting function
      translate / transform
      brush tool
      encircling path? 
      label? 
      refine colliding to 'harden' boundaries between bins? bounding box "view-source:http://mbostock.github.io/d3/talk/20110921/bounding.html"
      another way to pass data from one variable to another?

      Mapping label to a color
      deal with circles that have out-of-range input, transitions
      -->
      <style type="text/css">
      body { margin: 0px 0px 0px 0px; }
      </style>
   </head>
   <body>
      <div id = "tooltip"></div>
      <div id="body"></div>
      <script type="text/javascript">         
         var svg_height = 400;

         // Chart-level Attributes: sets the bin width, y-location, for the final bubble-axis-aligned graph.
         var binwidth = 23;
         var max_radius = 17;
         var max_binheight = 350;
         var chart_height = 400;
         var padding = 1;
         var svg_margin = 10;

         var main_chart_trans_y = 0;

         var main_svg = d3.select("body").append("svg:svg").attr("id", "main")
            .attr("width", 1200).attr("height", 800);

         /******/
         var company_data = [];
         var nested_data;
         var ndata_tot_size = [];
         var max_tot_size = 0; 
         var ndata_binheight = [];         
         d3.csv("data/proc_companies.csv", function(dataset) {
            dataset.forEach(function(d) {
               company_data.push({"name":d.name, "alias":d.alias, "symbol":d.symbol, "pos_x":+d.x, "pos_y":+d.y, "subpos_x":+d.cx, "subpos_y":+d.cy, "capital":+d.capitalization, "earnings":+d.earnings, "taxes":+d.taxes, "tax_rate":d.tax_rate * 100, "sector":d.sector, "tax_rate_bin":d.tax_rate_bin * 100})
            })
            nested_data = d3.nest()
               .key(function(d) { return d.tax_rate_bin; })
               .entries(company_data);
            
            // Calculate bin areas, height necessary //
            for (var i = 0; i < nested_data.length; i++) {
               ndata_tot_size[i] = 0;
               nested_data[i].values.forEach(function(d) { ndata_tot_size[i] += d.capital })
               if (ndata_tot_size[i] > max_tot_size) { max_tot_size = ndata_tot_size[i]; }
            }
            for (var i = 0; i < nested_data.length; i++) {
               ndata_binheight[i] = max_binheight * (Math.sqrt(ndata_tot_size[i]) / Math.sqrt(max_tot_size))
            }
            var line_ticks = []
            for (var i = 0; i < nested_data.length; i++) {         
               line_ticks[i] = sgm_on_line(binwidth, ndata_binheight[i], nested_data[i].values[0].tax_rate_bin, nested_data[i], main_chart_trans_y);
               line_ticks[i]()
            }
         });
         /******/

         /*********************************************/

         var across_ticks = [];
         setTimeout(function(g) {
            d3.selectAll(".o_circle").data().forEach(function(d, i) {
                  across_ticks[i] =  {"radius": d.radius, "x": d.x + (d.t_value / 2) * (binwidth + svg_margin) , "y": d.y + main_chart_trans_y + (svg_height - d.theight) / 2, "t_value": d.t_value, "name": d.name, "sector": d.sector, "tax_rate": d.tax_rate}
                  });
            d3.selectAll("div.tick").remove()
            main_svg.selectAll(".n_circle")
               .data(across_ticks, function(d) { return d.name; })
               .enter().append("circle")
               .attr("class", "n_circle")
               .attr("id", function(d) { return d.name; })
               .attr("fill", function(d) { return "rgba(96,96,96," + 0.35 * ((d.t_value / 2) % 2 + 1) + ")" ; })
               .attr("stroke", "white").attr("stroke-width", 1)
               .attr("cx", function(d, i) { return d.x + "px";})
               .attr("cy", function(d) { return d.y + "px" })
               .attr("r", function(d) { return d.radius; });
            }, 3500);

         var cluster_force = d3.layout.force()
         setTimeout(function(g) {
            cluster_force
                .nodes(across_ticks)
                .size([800, 600])
                .gravity(0)
                .friction(0.1)
                .charge(1)
                .on("tick", cluster_tick)
                .start()
            main_svg.append("svg:line")
                .attr("x1",svg_margin)
                .attr("y1", function() { return (main_chart_trans_y + chart_height) / 2; })
                .attr("x2",1200)
                .attr("y2", function() { return (main_chart_trans_y + chart_height) / 2; })
                .attr("stroke-width", 1)
                .attr("stroke", "rgba(96,96,96,0.75)")
                .style("shape-rendering", "crispEdges");
         }, 4000);
         

         var subchart_1_trans_y = 250;
         var filt_data;
         setTimeout(function(g) {
            var filt_data = d3.nest()
               .key(function(d) { return d.tax_rate_bin; })
               .entries(company_data.filter(function(d) { return d.sector == "Information technology"; }));
            max_binheight = 100;
            ndata_tot_size = [];
            max_tot_size = 0; 
            ndata_binheight = [];

            for (var i = 0; i < filt_data.length; i++) {
               ndata_tot_size[i] = 0;
               nested_data[i].values.forEach(function(d) { ndata_tot_size[i] += d.capital })
               if (ndata_tot_size[i] > max_tot_size) { max_tot_size = ndata_tot_size[i]; }
            }
            for (var i = 0; i < filt_data.length; i++) {
               ndata_binheight[i] = max_binheight * (Math.sqrt(ndata_tot_size[i]) / Math.sqrt(max_tot_size))
            }
            var line_ticks = []
            for (var i = 0; i < filt_data.length; i++) {         
               line_ticks[i] = sgm_on_line(binwidth, ndata_binheight[i], filt_data[i].values[0].tax_rate_bin, filt_data[i], subchart_1_trans_y);
               line_ticks[i]()
            }
         }, 5500);

         var filt_across_ticks = [];
         setTimeout(function(g) {
            d3.selectAll(".o_circle").data().forEach(function(d, i) {
                  filt_across_ticks[i] =  {"radius": d.radius, "x": d.x + (d.t_value / 2) * (binwidth + svg_margin) , "y": d.y + subchart_1_trans_y + (svg_height - d.theight) / 2, "t_value": d.t_value, "name": d.name, "sector": d.sector, "tax_rate": d.tax_rate}
               });
            d3.selectAll("div.tick").remove()
            main_svg.selectAll(".f_circle")
               .data(filt_across_ticks, function(d) { return d.name; })
               .enter().append("circle")
               .attr("class", "f_circle")
               .attr("fill", function(d) { return "rgba(96,96,96," + 0.35 * ((d.t_value / 2) % 2 + 1) + ")" ; })
               .attr("stroke", "white").attr("stroke-width", 1)
               .attr("cx", function(d, i) { return d.x + "px";})
               .attr("cy", function(d) { return d.y + "px" })
               .attr("r", function(d) { return d.radius; });
            }, 6500);

         var cluster_force = d3.layout.force()
         setTimeout(function(g) {
            cluster_force
                .nodes(filt_across_ticks)
                .size([800, 600])
                .gravity(0)
                .friction(0.1)
                .charge(1)
                .on("tick", cluster_sub_tick)
                .start()
            
            main_svg.append("svg:line")
                .attr("x1",svg_margin)
                .attr("y1", function() { return subchart_1_trans_y + (chart_height / 2); })
                .attr("x2",1200)
                .attr("y2", function() { return subchart_1_trans_y + (chart_height / 2); })
                .attr("stroke-width", 1)
                .attr("stroke", "rgba(96,96,96,0.75)")
                .style("shape-rendering", "crispEdges");
         }, 7500);

         var filt_clustered_pos = [];
         setTimeout(function(g) {
            d3.selectAll(".f_circle").data().forEach(function(d, i) { 
                     filt_clustered_pos[i] = {"radius": d.radius, "x": d.x, "y": d.y, "t_value": d.t_value, "name": d.name, "sector": d.sector, "tax_rate": d.tax_rate}
                  });
         }, 8000);
         setTimeout(function(g) {
            d3.selectAll(".f_circle").remove()
            d3.selectAll(".n_circle")
               .data(filt_clustered_pos, function(d) { return d.name; })
               .attr("id", function(d) { return d.name })
               .transition().duration(1200)
               .delay(function(d, i) { return (d.tax_rate / 100) * 1200; })
               .attr("cx", function(d) { return d.x; })
               .attr("cy", function(d) { return d.y; })
            
            d3.selectAll(".n_circle")
               .on("mouseover", function() { d3.select(this).attr("stroke", "black"); })
               .on("mouseout", function() { d3.select(this).attr("stroke", "white") });
         }, 9000);

      </script>
   </body>
</html>
