<html>
   <head>
      <script type="text/javascript" src="d3.v2.js"></script>
      <script type="text/javascript" src="treemap_data.js"></script>
      <script type="text/javascript" src="treemap_cluster_company.js"></script>
      <link rel="stylesheet" type="text/css" href="treemap_styles.css" />
      <!-- Group translate -->
      <!-- Infographic vs. data exploration -->
      <!--<script type="text/javascript" src="treemap_gen_tooltip.js"></script> -->
      <!--<script type="text/javascript" src="treemap_search_thru.js"></script> -->
      <!-- 
      To do: tooltip
      Adapt for d3.csv
      Extend, dive deeper into nesting function
      translate / transform
      brush tool
      encircling path? 
      label? 
      refine colliding to 'harden' boundaries between bins? bounding box "view-source:http://mbostock.github.io/d3/talk/20110921/bounding.html"
      another way to pass data from one variable to another?


      When should I use closures? When should I not? WTF is the deal with the SetTimeout callback functions????? Called functions vs. pointers to functions
      Why is it taking longer for the force layout to converge?????
      Mapping label to a color
      deal with circles that have out-of-range input, transitions
      need nested selections?
      -->
   </head>
   <body>
      <div id = "tooltip"></div>
      <div id="body"></div>
      <script type="text/javascript">         
         var svg_height = 400;

         // Chart-level Attributes: sets the bin width, y-location, for the final bubble-axis-aligned graph.
         var binwidth = 23;
         var max_radius = 17;
         var max_binheight = 350;
         var chart_height = 400;
         var padding = 1;
         var svg_margin = 10;

         var main_chart_trans_y = 0;
         var subchart_1_trans_y = 250;

         var main_svg = d3.select("body").append("svg:svg").attr("id", "main")
            .attr("width", 1200).attr("height", 800);

         /******/
         var company_data = [], nested_data;
         var ndata_tot_size = [], max_tot_size = 0, ndata_binheight = [];
         d3.csv("data/proc_companies.csv", function(dataset) {
            dataset.forEach(function(d) {
               company_data.push({
                  "name":d.name, "alias":d.alias, "symbol":d.symbol, 
                  "pos_x":Math.floor(d.x), "pos_y":Math.floor(d.y), "subpos_x":Math.floor(d.cx), "subpos_y":Math.floor(d.cy), 
                  "capital":Math.floor(d.capitalization), "earnings":Math.floor(d.earnings), "taxes":Math.floor(d.taxes), 
                  "tax_rate":d.tax_rate * 100, "sector":d.sector, "tax_rate_bin":Math.floor(d.tax_rate_bin * 100)
                  })
            })
            nested_data = d3.nest()
               .key(function(d) { return d.tax_rate_bin; })
               .entries(company_data);
            
            // Calculate bin areas, height necessary //
            for (var i = 0; i < nested_data.length; i++) {
               ndata_tot_size[i] = 0;
               nested_data[i].values.forEach(function(d) { ndata_tot_size[i] += d.capital })
               if (ndata_tot_size[i] > max_tot_size) { max_tot_size = ndata_tot_size[i]; }
            }
            for (var i = 0; i < nested_data.length; i++) {
               ndata_binheight[i] = max_binheight * (Math.sqrt(ndata_tot_size[i]) / Math.sqrt(max_tot_size))
            }
            var line_ticks = []
            for (var i = 0; i < nested_data.length; i++) {         
               line_ticks[i] = sgm_on_line(binwidth, ndata_binheight[i], nested_data[i].values[0].tax_rate_bin, nested_data[i], main_chart_trans_y);
               line_ticks[i]()
            }   
         });
         /******/

         /*********************************************/
         main_svg.append("svg:line")
             .attr("class", "x_line")
             .attr("x1", svg_margin)
             .attr("y1", function() { return (main_chart_trans_y + chart_height) / 2; })
             .attr("x2", 1200)
             .attr("y2", function() { return (main_chart_trans_y + chart_height) / 2; });

         main_svg.append("svg:line")
            .attr("x1",svg_margin)
            .attr("y1", function() { return subchart_1_trans_y + (chart_height / 2); })
            .attr("x2",1200)
            .attr("y2", function() { return subchart_1_trans_y + (chart_height / 2); })
            .attr("class", "x_line");

         var flattened_data_w_pos = [];
         var full_data_flatten;
         full_data_flatten = flatten_placed_bubbles("n_circle", flattened_data_w_pos, 0)
         var full_tick_fn = cluster_tick_fn()
         full_tick_fn.set_obj_id("n_circle").set_data_id(flattened_data_w_pos)

         var full_data_cluster_fn;         
         
         var full_cluster_force = d3.layout.force()
         setTimeout(full_data_flatten, 3500);
         setTimeout(function() {
            full_data_cluster_fn = apply_cluster_force_algo("n_circle", flattened_data_w_pos, full_tick_fn, full_cluster_force)
         }, 3750)
         setTimeout(full_data_cluster_fn, 4000);

         var filt_data;
         setTimeout(function(g) {
            filt_data = d3.nest()
               .key(function(d) { return d.tax_rate_bin; })
               .entries(company_data.filter(function(d) { return d.sector == "Information technology"; }));
            max_binheight = 100;
            ndata_tot_size = [], max_tot_size = 0, ndata_binheight = [];

            for (var i = 0; i < filt_data.length; i++) {
               ndata_tot_size[i] = 0;
               nested_data[i].values.forEach(function(d) { ndata_tot_size[i] += d.capital })
               if (ndata_tot_size[i] > max_tot_size) { max_tot_size = ndata_tot_size[i]; }
            }
            for (var i = 0; i < filt_data.length; i++) {
               ndata_binheight[i] = max_binheight * (Math.sqrt(ndata_tot_size[i]) / Math.sqrt(max_tot_size))
            }
            var line_ticks = []
            for (var i = 0; i < filt_data.length; i++) {         
               line_ticks[i] = sgm_on_line(binwidth, ndata_binheight[i], filt_data[i].values[0].tax_rate_bin, filt_data[i], subchart_1_trans_y);
               line_ticks[i]()
            }
         }, 5500);

         var filt_flattened_data_w_pos = [];
         var filt_data_flatten = flatten_placed_bubbles("f_circle", filt_flattened_data_w_pos, subchart_1_trans_y)
         
         var filt_tick_fn = cluster_tick_fn()
         filt_tick_fn.set_obj_id("f_circle").set_data_id(filt_flattened_data_w_pos)

         var filt_data_cluster_fn;
         var filt_cluster_force = d3.layout.force()
         
         setTimeout(filt_data_flatten, 6500);
         setTimeout(function() {            
            filt_data_cluster_fn = apply_cluster_force_algo("f_circle", filt_flattened_data_w_pos, filt_tick_fn, filt_cluster_force)
         }, 7250);         
         setTimeout(filt_data_cluster_fn, 7500);

         var filt_clustered_pos = [];
         setTimeout(function(g) {
            d3.selectAll(".f_circle").data().forEach(function(d, i) { 
                     filt_clustered_pos[i] = {"radius": d.radius, "x": d.x, "y": d.y, "t_value": d.t_value, "name": d.name, "sector": d.sector, "tax_rate": d.tax_rate}
                  });         
            d3.selectAll(".f_circle").remove()
            d3.selectAll(".n_circle")
               .data(filt_clustered_pos, function(d) { return d.name; })
               .attr("id", function(d) { return d.name })
               .transition().duration(1200)
               .delay(function(d, i) { return (d.tax_rate / 100) * 1200; })
               .attr("cx", function(d) { return d.x; })
               .attr("cy", function(d) { return d.y; })
            

         }, 15000);
         setTimeout(function(g) {
            console.log("try now")
            d3.selectAll(".n_circle")
               .on("mouseover", function() { d3.select(this).attr("stroke", "black"); })
               .on("mouseout", function() { d3.select(this).attr("stroke", "white"); });
         }, 18000);
         // stroke: white;
         function flatten_placed_bubbles(out_circle_id, dataset_id, y_displace) {
            function flatten_placed_bubbles() {
               d3.selectAll(".by_tick_circle").data().forEach(function(d, i) {
                     dataset_id[i] =  {
                        "radius": d.radius, 
                        "x": d.x + (d.t_value / 2) * (binwidth + svg_margin), 
                        "y": d.y + main_chart_trans_y + y_displace + (svg_height - d.theight) / 2, 
                        "t_value": d.t_value, 
                        "name": d.name, 
                        "sector": d.sector, 
                        "tax_rate": d.tax_rate}
                     });
               d3.selectAll("div.tick").remove()
               main_svg.selectAll("." + out_circle_id)
                  .data(dataset_id, function(d) { return d.name; })
                  .enter().append("circle")
                  .attr("class", out_circle_id).attr("id", function(d) { return d.name; })
                  .attr("fill", function(d) { return "rgba(96,96,96," + 0.35 * ((d.t_value / 2) % 2 + 1) + ")" ; })
                  .attr("cx", function(d, i) { return d.x; })
                  .attr("cy", function(d) { return d.y; })
                  .attr("r", function(d) { return d.radius; });
            }
            return flatten_placed_bubbles;
         }

         function apply_cluster_force_algo(obj_id, dataset, tick_fn, force_layout) {
            force_layout
               .nodes(dataset).size([800, 600])
               .gravity(0).friction(0.1).charge(1)
               .on("tick", tick_fn)
               .start();
         }
      </script>
   </body>
</html>
